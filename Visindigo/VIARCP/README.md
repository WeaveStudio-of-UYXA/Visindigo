# Application Remote Call Protocol
ARCP是适用于应用程序远程调用过程的协议，此协议具有以下特点：
1. 总体按RIFF思路设计，适用于函数调用
2. 明文传输，不加密
3. 传输数据类型严格序列化，可以快速解析
4. 只要求函数名是UTF-8编码的字符串，不对其他位置出现的字符串做编码要求
5. 务必注意所有基本数字类型的数据段都是**小端序**，其他类型的数据段都是**大端序**

因此，不应该通过ARCP传输隐私数据，或直接向互联网进行公开。ARCP应当仅被用作本地程序间或受信任的安全远程连接中的远程程序间的调用。

# Data Chunk
在ARCP中，所有的数据都是以Chunk的形式传输的，Chunk的基本格式如下：
* uint32 ：数据段长度L1（字节）
* uint16：类型名长度L2（字节）
* char[ L1 ] ：数据段
* char[ L2 ] ：类型名

其中的数据段和类型名都是可选的，如果不需要某个部分，将对应的L1或L2设置为0即可。但无论如何，Chunk的长度至少为48位，即6字节。

# CALL (REQUEST)
在调用时，调用方发送一个由若干Chunk组成的数据报，其中
第一个Chunk为 ARCP Chunk，这个Chunk也符合Data Chunk的格式，但具体内容定义如下：
* uint32：固定为 8（注意为小端序）
* uint16：协议版本号长度 2
* uint64：“ARCP\r\n\r\n"的字面连续值0x415243500D0A0D0A（注意为小端序）
* uint16：协议版本号
  
第二个Chunk为 CALL Chunk，它也是一个符合Data Chunk但有具体内容定义的区块，即：
* uint32：固定为 8 （注意为小端序）
* uint16：函数名长度L2（字节）
* uint32：“CALL”的字面连续值0x43414C4C（注意为小端序）
* uint32：参数数量N（字节）
* char[ L2 ] ：函数名

此Chunk后方N个Chunk为 Data Chunk。
参数数量N必须和后方的Chunk数量相同，这影响对方的解析策略，如果对方按N解析后，下一个Chunk不是ARCP Chunk（即下一报），则对方有权断开连接。

# RETURN (RESPONSE)
在返回时，被调用方发送一个由若干Chunk组成的数据报，其中第一个Chunk固定为 ARCP Chunk：
Chunk的格式，但具体内容定义如下：
* uint32：固定为 8（注意为小端序）
* uint16：协议版本号长度 2
* uint64：“ARCP\r\n\r\n"的字面连续值0x415243500D0A0D0A（注意为小端序）
* uint16：协议版本号
* 
第二个Chunk为 RETN Chunk，它和CALL Chunk类似其格式如下：
* uint32 字节：固定为 8 （注意为小端序）
* uint16 字节：状态码长度 2
* uint32字节：“RETN" 的字面连续值0x5245544E（注意为小端序）
* uint32字节：返回值数量N（字节）
* uint16 字节：状态码

此Chunk后方N个Chunk为 Data Chunk。
返回值数量N必须和后方的Chunk数量相同，这影响对方的解析策略，如果对方按N解析后，下一个Chunk不是ARCP Chunk（即下一报），则对方有权断开连接。

# ARCP CHUNK 匹配标准
1. 前4字节固定为0x08, 0x00, 0x00, 0x00
2. 出示的协议版本号在本地支持的版本号列表中
3. 从第7个字节起的八个字节固定为字符串“ARCP\r\n\r\n"的字面连续值0x415243500D0A0D0A，注意即小端序的0x0A, 0x0D, 0x0A, 0x0D, 0x50, 0x43, 0x52, 0x41
4. 是缓冲区中的第一个Chunk

# 状态码
ARCP状态码和HTTP状态码分类、含义均不相同，详见下表
## 通识状态码
通识状态码不仅用于ARCP报文中，也在ARCP终端内部使用。
| 0x00** 通识状态码 | 描述 |
| --- | --- |
| 0x0000 | 成功 |
| 0x0001 | 未知错误 |
| 0x0002 | 内部异常 |
| 0x0003 | 链接断开 |

## 调用状态码
调用状态码用于表示调用的执行状态
| 0x01** 调用状态码 | 描述 |
| --- | --- |
| 0x0101 | 未知函数 |
| 0x0102 | 参数类型不匹配 |
| 0x0103 | 参数数量不匹配 |
| 0x0104 | 对方抛出异常 |
| 0x0105 | 应向第一个返回值出示的函数名重新调用函数（重定向） |
| 0x0106 | 此函数已经注册，但未实现 |

## 解析状态码
解析状态码用于表示解析过程中的错误
| 0x02** 解析状态码 | 描述 |
| --- | --- |
| 0x0201 | Chunk 解析错误 |
| 0x0202 | 没有CALL Chunk |
| 0x0203 | 没有RETN Chunk |
| 0x0204 | CALL Chunk或RETN Chunk不合法 |
| 0x0205 | 报文头部长度不是ARCP Chunk（20字节） |
| 0x0206 | 报文头部不是合法的ARCP Chunk |
| 0x0207 | 未知协议版本 |

## 保留的状态码
从0x03** 到0x7F** 的状态码为保留状态码，用于未来扩展。
| 状态码 | 描述 |
| --- | --- |
| 0xFFFF | 未知状态码 |

# 保留的类型名
| 类型名 | 描述 |
| --- | --- |
| exception | 用于被请求者决定抛出异常时传递异常信息 |
| error | 用于被请求者决定阐述错误详情时传递错误信息 |
| terminal | 用于ARCP客户端之间的内部协调时的数据传递 |
| Unknown | 用于表达未在本地注册的类型 |
| Any | 用于表达任意类型 |
| None | 用于表达空值 |
| UInt32, Int32, UInt64, Int64, Float, Double, Bool | 用于表达基本数字类型 |
| String | 用于表达字符串，严格为Utf8的字符串 |
| Json | 用于表达Json对象，严格为Utf8的Json字符串 |
| Binary | 用于表达二进制数据，严格为char数组 |
